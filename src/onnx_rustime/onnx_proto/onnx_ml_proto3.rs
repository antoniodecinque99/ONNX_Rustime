// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `onnx-ml.proto3`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AttributeProto {
    // message fields
    pub name: ::std::string::String,
    pub ref_attr_name: ::std::string::String,
    pub doc_string: ::std::string::String,
    pub field_type: AttributeProto_AttributeType,
    pub f: f32,
    pub i: i64,
    pub s: ::std::vec::Vec<u8>,
    pub t: ::protobuf::SingularPtrField<TensorProto>,
    pub g: ::protobuf::SingularPtrField<GraphProto>,
    pub sparse_tensor: ::protobuf::SingularPtrField<SparseTensorProto>,
    pub tp: ::protobuf::SingularPtrField<TypeProto>,
    pub floats: ::std::vec::Vec<f32>,
    pub ints: ::std::vec::Vec<i64>,
    pub strings: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub tensors: ::protobuf::RepeatedField<TensorProto>,
    pub graphs: ::protobuf::RepeatedField<GraphProto>,
    pub sparse_tensors: ::protobuf::RepeatedField<SparseTensorProto>,
    pub type_protos: ::protobuf::RepeatedField<TypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeProto {
    fn default() -> &'a AttributeProto {
        <AttributeProto as ::protobuf::Message>::default_instance()
    }
}

impl AttributeProto {
    pub fn new() -> AttributeProto {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string ref_attr_name = 21;


    pub fn get_ref_attr_name(&self) -> &str {
        &self.ref_attr_name
    }
    pub fn clear_ref_attr_name(&mut self) {
        self.ref_attr_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_ref_attr_name(&mut self, v: ::std::string::String) {
        self.ref_attr_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref_attr_name(&mut self) -> &mut ::std::string::String {
        &mut self.ref_attr_name
    }

    // Take field
    pub fn take_ref_attr_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ref_attr_name, ::std::string::String::new())
    }

    // string doc_string = 13;


    pub fn get_doc_string(&self) -> &str {
        &self.doc_string
    }
    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        &mut self.doc_string
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc_string, ::std::string::String::new())
    }

    // .onnx.AttributeProto.AttributeType type = 20;


    pub fn get_field_type(&self) -> AttributeProto_AttributeType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AttributeProto_AttributeType::UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AttributeProto_AttributeType) {
        self.field_type = v;
    }

    // float f = 2;


    pub fn get_f(&self) -> f32 {
        self.f
    }
    pub fn clear_f(&mut self) {
        self.f = 0.;
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: f32) {
        self.f = v;
    }

    // int64 i = 3;


    pub fn get_i(&self) -> i64 {
        self.i
    }
    pub fn clear_i(&mut self) {
        self.i = 0;
    }

    // Param is passed by value, moved
    pub fn set_i(&mut self, v: i64) {
        self.i = v;
    }

    // bytes s = 4;


    pub fn get_s(&self) -> &[u8] {
        &self.s
    }
    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::std::vec::Vec<u8>) {
        self.s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.s
    }

    // Take field
    pub fn take_s(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.s, ::std::vec::Vec::new())
    }

    // .onnx.TensorProto t = 5;


    pub fn get_t(&self) -> &TensorProto {
        self.t.as_ref().unwrap_or_else(|| <TensorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: TensorProto) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut TensorProto {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> TensorProto {
        self.t.take().unwrap_or_else(|| TensorProto::new())
    }

    // .onnx.GraphProto g = 6;


    pub fn get_g(&self) -> &GraphProto {
        self.g.as_ref().unwrap_or_else(|| <GraphProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_g(&mut self) {
        self.g.clear();
    }

    pub fn has_g(&self) -> bool {
        self.g.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g(&mut self, v: GraphProto) {
        self.g = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_g(&mut self) -> &mut GraphProto {
        if self.g.is_none() {
            self.g.set_default();
        }
        self.g.as_mut().unwrap()
    }

    // Take field
    pub fn take_g(&mut self) -> GraphProto {
        self.g.take().unwrap_or_else(|| GraphProto::new())
    }

    // .onnx.SparseTensorProto sparse_tensor = 22;


    pub fn get_sparse_tensor(&self) -> &SparseTensorProto {
        self.sparse_tensor.as_ref().unwrap_or_else(|| <SparseTensorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sparse_tensor(&mut self) {
        self.sparse_tensor.clear();
    }

    pub fn has_sparse_tensor(&self) -> bool {
        self.sparse_tensor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sparse_tensor(&mut self, v: SparseTensorProto) {
        self.sparse_tensor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sparse_tensor(&mut self) -> &mut SparseTensorProto {
        if self.sparse_tensor.is_none() {
            self.sparse_tensor.set_default();
        }
        self.sparse_tensor.as_mut().unwrap()
    }

    // Take field
    pub fn take_sparse_tensor(&mut self) -> SparseTensorProto {
        self.sparse_tensor.take().unwrap_or_else(|| SparseTensorProto::new())
    }

    // .onnx.TypeProto tp = 14;


    pub fn get_tp(&self) -> &TypeProto {
        self.tp.as_ref().unwrap_or_else(|| <TypeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tp(&mut self) {
        self.tp.clear();
    }

    pub fn has_tp(&self) -> bool {
        self.tp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp(&mut self, v: TypeProto) {
        self.tp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tp(&mut self) -> &mut TypeProto {
        if self.tp.is_none() {
            self.tp.set_default();
        }
        self.tp.as_mut().unwrap()
    }

    // Take field
    pub fn take_tp(&mut self) -> TypeProto {
        self.tp.take().unwrap_or_else(|| TypeProto::new())
    }

    // repeated float floats = 7;


    pub fn get_floats(&self) -> &[f32] {
        &self.floats
    }
    pub fn clear_floats(&mut self) {
        self.floats.clear();
    }

    // Param is passed by value, moved
    pub fn set_floats(&mut self, v: ::std::vec::Vec<f32>) {
        self.floats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_floats(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.floats
    }

    // Take field
    pub fn take_floats(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.floats, ::std::vec::Vec::new())
    }

    // repeated int64 ints = 8;


    pub fn get_ints(&self) -> &[i64] {
        &self.ints
    }
    pub fn clear_ints(&mut self) {
        self.ints.clear();
    }

    // Param is passed by value, moved
    pub fn set_ints(&mut self, v: ::std::vec::Vec<i64>) {
        self.ints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ints(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.ints
    }

    // Take field
    pub fn take_ints(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.ints, ::std::vec::Vec::new())
    }

    // repeated bytes strings = 9;


    pub fn get_strings(&self) -> &[::std::vec::Vec<u8>] {
        &self.strings
    }
    pub fn clear_strings(&mut self) {
        self.strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_strings(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_strings(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.strings
    }

    // Take field
    pub fn take_strings(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.strings, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.TensorProto tensors = 10;


    pub fn get_tensors(&self) -> &[TensorProto] {
        &self.tensors
    }
    pub fn clear_tensors(&mut self) {
        self.tensors.clear();
    }

    // Param is passed by value, moved
    pub fn set_tensors(&mut self, v: ::protobuf::RepeatedField<TensorProto>) {
        self.tensors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tensors(&mut self) -> &mut ::protobuf::RepeatedField<TensorProto> {
        &mut self.tensors
    }

    // Take field
    pub fn take_tensors(&mut self) -> ::protobuf::RepeatedField<TensorProto> {
        ::std::mem::replace(&mut self.tensors, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.GraphProto graphs = 11;


    pub fn get_graphs(&self) -> &[GraphProto] {
        &self.graphs
    }
    pub fn clear_graphs(&mut self) {
        self.graphs.clear();
    }

    // Param is passed by value, moved
    pub fn set_graphs(&mut self, v: ::protobuf::RepeatedField<GraphProto>) {
        self.graphs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graphs(&mut self) -> &mut ::protobuf::RepeatedField<GraphProto> {
        &mut self.graphs
    }

    // Take field
    pub fn take_graphs(&mut self) -> ::protobuf::RepeatedField<GraphProto> {
        ::std::mem::replace(&mut self.graphs, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.SparseTensorProto sparse_tensors = 23;


    pub fn get_sparse_tensors(&self) -> &[SparseTensorProto] {
        &self.sparse_tensors
    }
    pub fn clear_sparse_tensors(&mut self) {
        self.sparse_tensors.clear();
    }

    // Param is passed by value, moved
    pub fn set_sparse_tensors(&mut self, v: ::protobuf::RepeatedField<SparseTensorProto>) {
        self.sparse_tensors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sparse_tensors(&mut self) -> &mut ::protobuf::RepeatedField<SparseTensorProto> {
        &mut self.sparse_tensors
    }

    // Take field
    pub fn take_sparse_tensors(&mut self) -> ::protobuf::RepeatedField<SparseTensorProto> {
        ::std::mem::replace(&mut self.sparse_tensors, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.TypeProto type_protos = 15;


    pub fn get_type_protos(&self) -> &[TypeProto] {
        &self.type_protos
    }
    pub fn clear_type_protos(&mut self) {
        self.type_protos.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_protos(&mut self, v: ::protobuf::RepeatedField<TypeProto>) {
        self.type_protos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_type_protos(&mut self) -> &mut ::protobuf::RepeatedField<TypeProto> {
        &mut self.type_protos
    }

    // Take field
    pub fn take_type_protos(&mut self) -> ::protobuf::RepeatedField<TypeProto> {
        ::std::mem::replace(&mut self.type_protos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AttributeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.g {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sparse_tensor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tensors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graphs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sparse_tensors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.type_protos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ref_attr_name)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc_string)?;
                },
                20 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 20, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.f = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.i = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.s)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.g)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sparse_tensor)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tp)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.floats)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.ints)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.strings)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tensors)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.graphs)?;
                },
                23 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sparse_tensors)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.type_protos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.ref_attr_name.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.ref_attr_name);
        }
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.doc_string);
        }
        if self.field_type != AttributeProto_AttributeType::UNDEFINED {
            my_size += ::protobuf::rt::enum_size(20, self.field_type);
        }
        if self.f != 0. {
            my_size += 5;
        }
        if self.i != 0 {
            my_size += ::protobuf::rt::value_size(3, self.i, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.s);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.g.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sparse_tensor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.floats.len() as u32;
        for value in &self.ints {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.strings {
            my_size += ::protobuf::rt::bytes_size(9, &value);
        };
        for value in &self.tensors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sparse_tensors {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.type_protos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.ref_attr_name.is_empty() {
            os.write_string(21, &self.ref_attr_name)?;
        }
        if !self.doc_string.is_empty() {
            os.write_string(13, &self.doc_string)?;
        }
        if self.field_type != AttributeProto_AttributeType::UNDEFINED {
            os.write_enum(20, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.f != 0. {
            os.write_float(2, self.f)?;
        }
        if self.i != 0 {
            os.write_int64(3, self.i)?;
        }
        if !self.s.is_empty() {
            os.write_bytes(4, &self.s)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.g.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sparse_tensor.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tp.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.floats {
            os.write_float(7, *v)?;
        };
        for v in &self.ints {
            os.write_int64(8, *v)?;
        };
        for v in &self.strings {
            os.write_bytes(9, &v)?;
        };
        for v in &self.tensors {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.graphs {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sparse_tensors {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.type_protos {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeProto {
        AttributeProto::new()
    }

    fn default_instance() -> &'static AttributeProto {
        static instance: ::protobuf::rt::LazyV2<AttributeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AttributeProto::new)
    }
}

impl ::protobuf::Clear for AttributeProto {
    fn clear(&mut self) {
        self.name.clear();
        self.ref_attr_name.clear();
        self.doc_string.clear();
        self.field_type = AttributeProto_AttributeType::UNDEFINED;
        self.f = 0.;
        self.i = 0;
        self.s.clear();
        self.t.clear();
        self.g.clear();
        self.sparse_tensor.clear();
        self.tp.clear();
        self.floats.clear();
        self.ints.clear();
        self.strings.clear();
        self.tensors.clear();
        self.graphs.clear();
        self.sparse_tensors.clear();
        self.type_protos.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AttributeProto_AttributeType {
    UNDEFINED = 0,
    FLOAT = 1,
    INT = 2,
    STRING = 3,
    TENSOR = 4,
    GRAPH = 5,
    SPARSE_TENSOR = 11,
    TYPE_PROTO = 13,
    FLOATS = 6,
    INTS = 7,
    STRINGS = 8,
    TENSORS = 9,
    GRAPHS = 10,
    SPARSE_TENSORS = 12,
    TYPE_PROTOS = 14,
}

impl ::protobuf::ProtobufEnum for AttributeProto_AttributeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AttributeProto_AttributeType> {
        match value {
            0 => ::std::option::Option::Some(AttributeProto_AttributeType::UNDEFINED),
            1 => ::std::option::Option::Some(AttributeProto_AttributeType::FLOAT),
            2 => ::std::option::Option::Some(AttributeProto_AttributeType::INT),
            3 => ::std::option::Option::Some(AttributeProto_AttributeType::STRING),
            4 => ::std::option::Option::Some(AttributeProto_AttributeType::TENSOR),
            5 => ::std::option::Option::Some(AttributeProto_AttributeType::GRAPH),
            11 => ::std::option::Option::Some(AttributeProto_AttributeType::SPARSE_TENSOR),
            13 => ::std::option::Option::Some(AttributeProto_AttributeType::TYPE_PROTO),
            6 => ::std::option::Option::Some(AttributeProto_AttributeType::FLOATS),
            7 => ::std::option::Option::Some(AttributeProto_AttributeType::INTS),
            8 => ::std::option::Option::Some(AttributeProto_AttributeType::STRINGS),
            9 => ::std::option::Option::Some(AttributeProto_AttributeType::TENSORS),
            10 => ::std::option::Option::Some(AttributeProto_AttributeType::GRAPHS),
            12 => ::std::option::Option::Some(AttributeProto_AttributeType::SPARSE_TENSORS),
            14 => ::std::option::Option::Some(AttributeProto_AttributeType::TYPE_PROTOS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AttributeProto_AttributeType] = &[
            AttributeProto_AttributeType::UNDEFINED,
            AttributeProto_AttributeType::FLOAT,
            AttributeProto_AttributeType::INT,
            AttributeProto_AttributeType::STRING,
            AttributeProto_AttributeType::TENSOR,
            AttributeProto_AttributeType::GRAPH,
            AttributeProto_AttributeType::SPARSE_TENSOR,
            AttributeProto_AttributeType::TYPE_PROTO,
            AttributeProto_AttributeType::FLOATS,
            AttributeProto_AttributeType::INTS,
            AttributeProto_AttributeType::STRINGS,
            AttributeProto_AttributeType::TENSORS,
            AttributeProto_AttributeType::GRAPHS,
            AttributeProto_AttributeType::SPARSE_TENSORS,
            AttributeProto_AttributeType::TYPE_PROTOS,
        ];
        values
    }
}

impl ::std::marker::Copy for AttributeProto_AttributeType {
}

impl ::std::default::Default for AttributeProto_AttributeType {
    fn default() -> Self {
        AttributeProto_AttributeType::UNDEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeProto_AttributeType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValueInfoProto {
    // message fields
    pub name: ::std::string::String,
    pub field_type: ::protobuf::SingularPtrField<TypeProto>,
    pub doc_string: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValueInfoProto {
    fn default() -> &'a ValueInfoProto {
        <ValueInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl ValueInfoProto {
    pub fn new() -> ValueInfoProto {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .onnx.TypeProto type = 2;


    pub fn get_field_type(&self) -> &TypeProto {
        self.field_type.as_ref().unwrap_or_else(|| <TypeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TypeProto) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut TypeProto {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> TypeProto {
        self.field_type.take().unwrap_or_else(|| TypeProto::new())
    }

    // string doc_string = 3;


    pub fn get_doc_string(&self) -> &str {
        &self.doc_string
    }
    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        &mut self.doc_string
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc_string, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ValueInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.doc_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.doc_string.is_empty() {
            os.write_string(3, &self.doc_string)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValueInfoProto {
        ValueInfoProto::new()
    }

    fn default_instance() -> &'static ValueInfoProto {
        static instance: ::protobuf::rt::LazyV2<ValueInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValueInfoProto::new)
    }
}

impl ::protobuf::Clear for ValueInfoProto {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type.clear();
        self.doc_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeProto {
    // message fields
    pub input: ::protobuf::RepeatedField<::std::string::String>,
    pub output: ::protobuf::RepeatedField<::std::string::String>,
    pub name: ::std::string::String,
    pub op_type: ::std::string::String,
    pub domain: ::std::string::String,
    pub attribute: ::protobuf::RepeatedField<AttributeProto>,
    pub doc_string: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeProto {
    fn default() -> &'a NodeProto {
        <NodeProto as ::protobuf::Message>::default_instance()
    }
}

impl NodeProto {
    pub fn new() -> NodeProto {
        ::std::default::Default::default()
    }

    // repeated string input = 1;


    pub fn get_input(&self) -> &[::std::string::String] {
        &self.input
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input
    }

    // Take field
    pub fn take_input(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input, ::protobuf::RepeatedField::new())
    }

    // repeated string output = 2;


    pub fn get_output(&self) -> &[::std::string::String] {
        &self.output
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.output = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.output, ::protobuf::RepeatedField::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string op_type = 4;


    pub fn get_op_type(&self) -> &str {
        &self.op_type
    }
    pub fn clear_op_type(&mut self) {
        self.op_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_op_type(&mut self, v: ::std::string::String) {
        self.op_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_type(&mut self) -> &mut ::std::string::String {
        &mut self.op_type
    }

    // Take field
    pub fn take_op_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op_type, ::std::string::String::new())
    }

    // string domain = 7;


    pub fn get_domain(&self) -> &str {
        &self.domain
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        &mut self.domain
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.domain, ::std::string::String::new())
    }

    // repeated .onnx.AttributeProto attribute = 5;


    pub fn get_attribute(&self) -> &[AttributeProto] {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::protobuf::RepeatedField<AttributeProto>) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute(&mut self) -> &mut ::protobuf::RepeatedField<AttributeProto> {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::protobuf::RepeatedField<AttributeProto> {
        ::std::mem::replace(&mut self.attribute, ::protobuf::RepeatedField::new())
    }

    // string doc_string = 6;


    pub fn get_doc_string(&self) -> &str {
        &self.doc_string
    }
    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        &mut self.doc_string
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc_string, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.output)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.domain)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attribute)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.output {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.op_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.op_type);
        }
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.domain);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.doc_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.input {
            os.write_string(1, &v)?;
        };
        for v in &self.output {
            os.write_string(2, &v)?;
        };
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.op_type.is_empty() {
            os.write_string(4, &self.op_type)?;
        }
        if !self.domain.is_empty() {
            os.write_string(7, &self.domain)?;
        }
        for v in &self.attribute {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.doc_string.is_empty() {
            os.write_string(6, &self.doc_string)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeProto {
        NodeProto::new()
    }

    fn default_instance() -> &'static NodeProto {
        static instance: ::protobuf::rt::LazyV2<NodeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeProto::new)
    }
}

impl ::protobuf::Clear for NodeProto {
    fn clear(&mut self) {
        self.input.clear();
        self.output.clear();
        self.name.clear();
        self.op_type.clear();
        self.domain.clear();
        self.attribute.clear();
        self.doc_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainingInfoProto {
    // message fields
    pub initialization: ::protobuf::SingularPtrField<GraphProto>,
    pub algorithm: ::protobuf::SingularPtrField<GraphProto>,
    pub initialization_binding: ::protobuf::RepeatedField<StringStringEntryProto>,
    pub update_binding: ::protobuf::RepeatedField<StringStringEntryProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrainingInfoProto {
    fn default() -> &'a TrainingInfoProto {
        <TrainingInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl TrainingInfoProto {
    pub fn new() -> TrainingInfoProto {
        ::std::default::Default::default()
    }

    // .onnx.GraphProto initialization = 1;


    pub fn get_initialization(&self) -> &GraphProto {
        self.initialization.as_ref().unwrap_or_else(|| <GraphProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initialization(&mut self) {
        self.initialization.clear();
    }

    pub fn has_initialization(&self) -> bool {
        self.initialization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialization(&mut self, v: GraphProto) {
        self.initialization = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initialization(&mut self) -> &mut GraphProto {
        if self.initialization.is_none() {
            self.initialization.set_default();
        }
        self.initialization.as_mut().unwrap()
    }

    // Take field
    pub fn take_initialization(&mut self) -> GraphProto {
        self.initialization.take().unwrap_or_else(|| GraphProto::new())
    }

    // .onnx.GraphProto algorithm = 2;


    pub fn get_algorithm(&self) -> &GraphProto {
        self.algorithm.as_ref().unwrap_or_else(|| <GraphProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_algorithm(&mut self) {
        self.algorithm.clear();
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: GraphProto) {
        self.algorithm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_algorithm(&mut self) -> &mut GraphProto {
        if self.algorithm.is_none() {
            self.algorithm.set_default();
        }
        self.algorithm.as_mut().unwrap()
    }

    // Take field
    pub fn take_algorithm(&mut self) -> GraphProto {
        self.algorithm.take().unwrap_or_else(|| GraphProto::new())
    }

    // repeated .onnx.StringStringEntryProto initialization_binding = 3;


    pub fn get_initialization_binding(&self) -> &[StringStringEntryProto] {
        &self.initialization_binding
    }
    pub fn clear_initialization_binding(&mut self) {
        self.initialization_binding.clear();
    }

    // Param is passed by value, moved
    pub fn set_initialization_binding(&mut self, v: ::protobuf::RepeatedField<StringStringEntryProto>) {
        self.initialization_binding = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initialization_binding(&mut self) -> &mut ::protobuf::RepeatedField<StringStringEntryProto> {
        &mut self.initialization_binding
    }

    // Take field
    pub fn take_initialization_binding(&mut self) -> ::protobuf::RepeatedField<StringStringEntryProto> {
        ::std::mem::replace(&mut self.initialization_binding, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.StringStringEntryProto update_binding = 4;


    pub fn get_update_binding(&self) -> &[StringStringEntryProto] {
        &self.update_binding
    }
    pub fn clear_update_binding(&mut self) {
        self.update_binding.clear();
    }

    // Param is passed by value, moved
    pub fn set_update_binding(&mut self, v: ::protobuf::RepeatedField<StringStringEntryProto>) {
        self.update_binding = v;
    }

    // Mutable pointer to the field.
    pub fn mut_update_binding(&mut self) -> &mut ::protobuf::RepeatedField<StringStringEntryProto> {
        &mut self.update_binding
    }

    // Take field
    pub fn take_update_binding(&mut self) -> ::protobuf::RepeatedField<StringStringEntryProto> {
        ::std::mem::replace(&mut self.update_binding, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TrainingInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.initialization {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.algorithm {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initialization_binding {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_binding {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initialization)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.algorithm)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initialization_binding)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.update_binding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.initialization.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.algorithm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.initialization_binding {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.update_binding {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.initialization.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.algorithm.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.initialization_binding {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.update_binding {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrainingInfoProto {
        TrainingInfoProto::new()
    }

    fn default_instance() -> &'static TrainingInfoProto {
        static instance: ::protobuf::rt::LazyV2<TrainingInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrainingInfoProto::new)
    }
}

impl ::protobuf::Clear for TrainingInfoProto {
    fn clear(&mut self) {
        self.initialization.clear();
        self.algorithm.clear();
        self.initialization_binding.clear();
        self.update_binding.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainingInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelProto {
    // message fields
    pub ir_version: i64,
    pub opset_import: ::protobuf::RepeatedField<OperatorSetIdProto>,
    pub producer_name: ::std::string::String,
    pub producer_version: ::std::string::String,
    pub domain: ::std::string::String,
    pub model_version: i64,
    pub doc_string: ::std::string::String,
    pub graph: ::protobuf::SingularPtrField<GraphProto>,
    pub metadata_props: ::protobuf::RepeatedField<StringStringEntryProto>,
    pub training_info: ::protobuf::RepeatedField<TrainingInfoProto>,
    pub functions: ::protobuf::RepeatedField<FunctionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelProto {
    fn default() -> &'a ModelProto {
        <ModelProto as ::protobuf::Message>::default_instance()
    }
}

impl ModelProto {
    pub fn new() -> ModelProto {
        ::std::default::Default::default()
    }

    // int64 ir_version = 1;


    pub fn get_ir_version(&self) -> i64 {
        self.ir_version
    }
    pub fn clear_ir_version(&mut self) {
        self.ir_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_ir_version(&mut self, v: i64) {
        self.ir_version = v;
    }

    // repeated .onnx.OperatorSetIdProto opset_import = 8;


    pub fn get_opset_import(&self) -> &[OperatorSetIdProto] {
        &self.opset_import
    }
    pub fn clear_opset_import(&mut self) {
        self.opset_import.clear();
    }

    // Param is passed by value, moved
    pub fn set_opset_import(&mut self, v: ::protobuf::RepeatedField<OperatorSetIdProto>) {
        self.opset_import = v;
    }

    // Mutable pointer to the field.
    pub fn mut_opset_import(&mut self) -> &mut ::protobuf::RepeatedField<OperatorSetIdProto> {
        &mut self.opset_import
    }

    // Take field
    pub fn take_opset_import(&mut self) -> ::protobuf::RepeatedField<OperatorSetIdProto> {
        ::std::mem::replace(&mut self.opset_import, ::protobuf::RepeatedField::new())
    }

    // string producer_name = 2;


    pub fn get_producer_name(&self) -> &str {
        &self.producer_name
    }
    pub fn clear_producer_name(&mut self) {
        self.producer_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_producer_name(&mut self, v: ::std::string::String) {
        self.producer_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_name(&mut self) -> &mut ::std::string::String {
        &mut self.producer_name
    }

    // Take field
    pub fn take_producer_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.producer_name, ::std::string::String::new())
    }

    // string producer_version = 3;


    pub fn get_producer_version(&self) -> &str {
        &self.producer_version
    }
    pub fn clear_producer_version(&mut self) {
        self.producer_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_producer_version(&mut self, v: ::std::string::String) {
        self.producer_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_version(&mut self) -> &mut ::std::string::String {
        &mut self.producer_version
    }

    // Take field
    pub fn take_producer_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.producer_version, ::std::string::String::new())
    }

    // string domain = 4;


    pub fn get_domain(&self) -> &str {
        &self.domain
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        &mut self.domain
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.domain, ::std::string::String::new())
    }

    // int64 model_version = 5;


    pub fn get_model_version(&self) -> i64 {
        self.model_version
    }
    pub fn clear_model_version(&mut self) {
        self.model_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_model_version(&mut self, v: i64) {
        self.model_version = v;
    }

    // string doc_string = 6;


    pub fn get_doc_string(&self) -> &str {
        &self.doc_string
    }
    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        &mut self.doc_string
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc_string, ::std::string::String::new())
    }

    // .onnx.GraphProto graph = 7;


    pub fn get_graph(&self) -> &GraphProto {
        self.graph.as_ref().unwrap_or_else(|| <GraphProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_graph(&mut self) {
        self.graph.clear();
    }

    pub fn has_graph(&self) -> bool {
        self.graph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graph(&mut self, v: GraphProto) {
        self.graph = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph(&mut self) -> &mut GraphProto {
        if self.graph.is_none() {
            self.graph.set_default();
        }
        self.graph.as_mut().unwrap()
    }

    // Take field
    pub fn take_graph(&mut self) -> GraphProto {
        self.graph.take().unwrap_or_else(|| GraphProto::new())
    }

    // repeated .onnx.StringStringEntryProto metadata_props = 14;


    pub fn get_metadata_props(&self) -> &[StringStringEntryProto] {
        &self.metadata_props
    }
    pub fn clear_metadata_props(&mut self) {
        self.metadata_props.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata_props(&mut self, v: ::protobuf::RepeatedField<StringStringEntryProto>) {
        self.metadata_props = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata_props(&mut self) -> &mut ::protobuf::RepeatedField<StringStringEntryProto> {
        &mut self.metadata_props
    }

    // Take field
    pub fn take_metadata_props(&mut self) -> ::protobuf::RepeatedField<StringStringEntryProto> {
        ::std::mem::replace(&mut self.metadata_props, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.TrainingInfoProto training_info = 20;


    pub fn get_training_info(&self) -> &[TrainingInfoProto] {
        &self.training_info
    }
    pub fn clear_training_info(&mut self) {
        self.training_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_training_info(&mut self, v: ::protobuf::RepeatedField<TrainingInfoProto>) {
        self.training_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_training_info(&mut self) -> &mut ::protobuf::RepeatedField<TrainingInfoProto> {
        &mut self.training_info
    }

    // Take field
    pub fn take_training_info(&mut self) -> ::protobuf::RepeatedField<TrainingInfoProto> {
        ::std::mem::replace(&mut self.training_info, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.FunctionProto functions = 25;


    pub fn get_functions(&self) -> &[FunctionProto] {
        &self.functions
    }
    pub fn clear_functions(&mut self) {
        self.functions.clear();
    }

    // Param is passed by value, moved
    pub fn set_functions(&mut self, v: ::protobuf::RepeatedField<FunctionProto>) {
        self.functions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_functions(&mut self) -> &mut ::protobuf::RepeatedField<FunctionProto> {
        &mut self.functions
    }

    // Take field
    pub fn take_functions(&mut self) -> ::protobuf::RepeatedField<FunctionProto> {
        ::std::mem::replace(&mut self.functions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ModelProto {
    fn is_initialized(&self) -> bool {
        for v in &self.opset_import {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graph {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata_props {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.training_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.functions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ir_version = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.opset_import)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.producer_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.producer_version)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.domain)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.model_version = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc_string)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graph)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata_props)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.training_info)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.functions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ir_version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ir_version, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.opset_import {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.producer_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.producer_name);
        }
        if !self.producer_version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.producer_version);
        }
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.domain);
        }
        if self.model_version != 0 {
            my_size += ::protobuf::rt::value_size(5, self.model_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.doc_string);
        }
        if let Some(ref v) = self.graph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metadata_props {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.training_info {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.functions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ir_version != 0 {
            os.write_int64(1, self.ir_version)?;
        }
        for v in &self.opset_import {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.producer_name.is_empty() {
            os.write_string(2, &self.producer_name)?;
        }
        if !self.producer_version.is_empty() {
            os.write_string(3, &self.producer_version)?;
        }
        if !self.domain.is_empty() {
            os.write_string(4, &self.domain)?;
        }
        if self.model_version != 0 {
            os.write_int64(5, self.model_version)?;
        }
        if !self.doc_string.is_empty() {
            os.write_string(6, &self.doc_string)?;
        }
        if let Some(ref v) = self.graph.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metadata_props {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.training_info {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.functions {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelProto {
        ModelProto::new()
    }

    fn default_instance() -> &'static ModelProto {
        static instance: ::protobuf::rt::LazyV2<ModelProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelProto::new)
    }
}

impl ::protobuf::Clear for ModelProto {
    fn clear(&mut self) {
        self.ir_version = 0;
        self.opset_import.clear();
        self.producer_name.clear();
        self.producer_version.clear();
        self.domain.clear();
        self.model_version = 0;
        self.doc_string.clear();
        self.graph.clear();
        self.metadata_props.clear();
        self.training_info.clear();
        self.functions.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StringStringEntryProto {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringStringEntryProto {
    fn default() -> &'a StringStringEntryProto {
        <StringStringEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl StringStringEntryProto {
    pub fn new() -> StringStringEntryProto {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StringStringEntryProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringStringEntryProto {
        StringStringEntryProto::new()
    }

    fn default_instance() -> &'static StringStringEntryProto {
        static instance: ::protobuf::rt::LazyV2<StringStringEntryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringStringEntryProto::new)
    }
}

impl ::protobuf::Clear for StringStringEntryProto {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StringStringEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TensorAnnotation {
    // message fields
    pub tensor_name: ::std::string::String,
    pub quant_parameter_tensor_names: ::protobuf::RepeatedField<StringStringEntryProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorAnnotation {
    fn default() -> &'a TensorAnnotation {
        <TensorAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl TensorAnnotation {
    pub fn new() -> TensorAnnotation {
        ::std::default::Default::default()
    }

    // string tensor_name = 1;


    pub fn get_tensor_name(&self) -> &str {
        &self.tensor_name
    }
    pub fn clear_tensor_name(&mut self) {
        self.tensor_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_tensor_name(&mut self, v: ::std::string::String) {
        self.tensor_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tensor_name(&mut self) -> &mut ::std::string::String {
        &mut self.tensor_name
    }

    // Take field
    pub fn take_tensor_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tensor_name, ::std::string::String::new())
    }

    // repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;


    pub fn get_quant_parameter_tensor_names(&self) -> &[StringStringEntryProto] {
        &self.quant_parameter_tensor_names
    }
    pub fn clear_quant_parameter_tensor_names(&mut self) {
        self.quant_parameter_tensor_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_quant_parameter_tensor_names(&mut self, v: ::protobuf::RepeatedField<StringStringEntryProto>) {
        self.quant_parameter_tensor_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quant_parameter_tensor_names(&mut self) -> &mut ::protobuf::RepeatedField<StringStringEntryProto> {
        &mut self.quant_parameter_tensor_names
    }

    // Take field
    pub fn take_quant_parameter_tensor_names(&mut self) -> ::protobuf::RepeatedField<StringStringEntryProto> {
        ::std::mem::replace(&mut self.quant_parameter_tensor_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TensorAnnotation {
    fn is_initialized(&self) -> bool {
        for v in &self.quant_parameter_tensor_names {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tensor_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.quant_parameter_tensor_names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tensor_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tensor_name);
        }
        for value in &self.quant_parameter_tensor_names {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tensor_name.is_empty() {
            os.write_string(1, &self.tensor_name)?;
        }
        for v in &self.quant_parameter_tensor_names {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorAnnotation {
        TensorAnnotation::new()
    }

    fn default_instance() -> &'static TensorAnnotation {
        static instance: ::protobuf::rt::LazyV2<TensorAnnotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorAnnotation::new)
    }
}

impl ::protobuf::Clear for TensorAnnotation {
    fn clear(&mut self) {
        self.tensor_name.clear();
        self.quant_parameter_tensor_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorAnnotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GraphProto {
    // message fields
    pub node: ::protobuf::RepeatedField<NodeProto>,
    pub name: ::std::string::String,
    pub initializer: ::protobuf::RepeatedField<TensorProto>,
    pub sparse_initializer: ::protobuf::RepeatedField<SparseTensorProto>,
    pub doc_string: ::std::string::String,
    pub input: ::protobuf::RepeatedField<ValueInfoProto>,
    pub output: ::protobuf::RepeatedField<ValueInfoProto>,
    pub value_info: ::protobuf::RepeatedField<ValueInfoProto>,
    pub quantization_annotation: ::protobuf::RepeatedField<TensorAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GraphProto {
    fn default() -> &'a GraphProto {
        <GraphProto as ::protobuf::Message>::default_instance()
    }
}

impl GraphProto {
    pub fn new() -> GraphProto {
        ::std::default::Default::default()
    }

    // repeated .onnx.NodeProto node = 1;


    pub fn get_node(&self) -> &[NodeProto] {
        &self.node
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: ::protobuf::RepeatedField<NodeProto>) {
        self.node = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node(&mut self) -> &mut ::protobuf::RepeatedField<NodeProto> {
        &mut self.node
    }

    // Take field
    pub fn take_node(&mut self) -> ::protobuf::RepeatedField<NodeProto> {
        ::std::mem::replace(&mut self.node, ::protobuf::RepeatedField::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .onnx.TensorProto initializer = 5;


    pub fn get_initializer(&self) -> &[TensorProto] {
        &self.initializer
    }
    pub fn clear_initializer(&mut self) {
        self.initializer.clear();
    }

    // Param is passed by value, moved
    pub fn set_initializer(&mut self, v: ::protobuf::RepeatedField<TensorProto>) {
        self.initializer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initializer(&mut self) -> &mut ::protobuf::RepeatedField<TensorProto> {
        &mut self.initializer
    }

    // Take field
    pub fn take_initializer(&mut self) -> ::protobuf::RepeatedField<TensorProto> {
        ::std::mem::replace(&mut self.initializer, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.SparseTensorProto sparse_initializer = 15;


    pub fn get_sparse_initializer(&self) -> &[SparseTensorProto] {
        &self.sparse_initializer
    }
    pub fn clear_sparse_initializer(&mut self) {
        self.sparse_initializer.clear();
    }

    // Param is passed by value, moved
    pub fn set_sparse_initializer(&mut self, v: ::protobuf::RepeatedField<SparseTensorProto>) {
        self.sparse_initializer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sparse_initializer(&mut self) -> &mut ::protobuf::RepeatedField<SparseTensorProto> {
        &mut self.sparse_initializer
    }

    // Take field
    pub fn take_sparse_initializer(&mut self) -> ::protobuf::RepeatedField<SparseTensorProto> {
        ::std::mem::replace(&mut self.sparse_initializer, ::protobuf::RepeatedField::new())
    }

    // string doc_string = 10;


    pub fn get_doc_string(&self) -> &str {
        &self.doc_string
    }
    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        &mut self.doc_string
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc_string, ::std::string::String::new())
    }

    // repeated .onnx.ValueInfoProto input = 11;


    pub fn get_input(&self) -> &[ValueInfoProto] {
        &self.input
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::protobuf::RepeatedField<ValueInfoProto>) {
        self.input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input(&mut self) -> &mut ::protobuf::RepeatedField<ValueInfoProto> {
        &mut self.input
    }

    // Take field
    pub fn take_input(&mut self) -> ::protobuf::RepeatedField<ValueInfoProto> {
        ::std::mem::replace(&mut self.input, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.ValueInfoProto output = 12;


    pub fn get_output(&self) -> &[ValueInfoProto] {
        &self.output
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::protobuf::RepeatedField<ValueInfoProto>) {
        self.output = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output(&mut self) -> &mut ::protobuf::RepeatedField<ValueInfoProto> {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::protobuf::RepeatedField<ValueInfoProto> {
        ::std::mem::replace(&mut self.output, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.ValueInfoProto value_info = 13;


    pub fn get_value_info(&self) -> &[ValueInfoProto] {
        &self.value_info
    }
    pub fn clear_value_info(&mut self) {
        self.value_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_info(&mut self, v: ::protobuf::RepeatedField<ValueInfoProto>) {
        self.value_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value_info(&mut self) -> &mut ::protobuf::RepeatedField<ValueInfoProto> {
        &mut self.value_info
    }

    // Take field
    pub fn take_value_info(&mut self) -> ::protobuf::RepeatedField<ValueInfoProto> {
        ::std::mem::replace(&mut self.value_info, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.TensorAnnotation quantization_annotation = 14;


    pub fn get_quantization_annotation(&self) -> &[TensorAnnotation] {
        &self.quantization_annotation
    }
    pub fn clear_quantization_annotation(&mut self) {
        self.quantization_annotation.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantization_annotation(&mut self, v: ::protobuf::RepeatedField<TensorAnnotation>) {
        self.quantization_annotation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quantization_annotation(&mut self) -> &mut ::protobuf::RepeatedField<TensorAnnotation> {
        &mut self.quantization_annotation
    }

    // Take field
    pub fn take_quantization_annotation(&mut self) -> ::protobuf::RepeatedField<TensorAnnotation> {
        ::std::mem::replace(&mut self.quantization_annotation, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GraphProto {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initializer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sparse_initializer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quantization_annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initializer)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sparse_initializer)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc_string)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.input)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.output)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value_info)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.quantization_annotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.initializer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sparse_initializer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.doc_string);
        }
        for value in &self.input {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.output {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.value_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.quantization_annotation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.node {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.initializer {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sparse_initializer {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.doc_string.is_empty() {
            os.write_string(10, &self.doc_string)?;
        }
        for v in &self.input {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.output {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.value_info {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.quantization_annotation {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphProto {
        GraphProto::new()
    }

    fn default_instance() -> &'static GraphProto {
        static instance: ::protobuf::rt::LazyV2<GraphProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GraphProto::new)
    }
}

impl ::protobuf::Clear for GraphProto {
    fn clear(&mut self) {
        self.node.clear();
        self.name.clear();
        self.initializer.clear();
        self.sparse_initializer.clear();
        self.doc_string.clear();
        self.input.clear();
        self.output.clear();
        self.value_info.clear();
        self.quantization_annotation.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TensorProto {
    // message fields
    pub dims: ::std::vec::Vec<i64>,
    pub data_type: i32,
    pub segment: ::protobuf::SingularPtrField<TensorProto_Segment>,
    pub float_data: ::std::vec::Vec<f32>,
    pub int32_data: ::std::vec::Vec<i32>,
    pub string_data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub int64_data: ::std::vec::Vec<i64>,
    pub name: ::std::string::String,
    pub doc_string: ::std::string::String,
    pub raw_data: ::std::vec::Vec<u8>,
    pub external_data: ::protobuf::RepeatedField<StringStringEntryProto>,
    pub data_location: TensorProto_DataLocation,
    pub double_data: ::std::vec::Vec<f64>,
    pub uint64_data: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorProto {
    fn default() -> &'a TensorProto {
        <TensorProto as ::protobuf::Message>::default_instance()
    }
}

impl TensorProto {
    pub fn new() -> TensorProto {
        ::std::default::Default::default()
    }

    // repeated int64 dims = 1;


    pub fn get_dims(&self) -> &[i64] {
        &self.dims
    }
    pub fn clear_dims(&mut self) {
        self.dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dims
    }

    // Take field
    pub fn take_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dims, ::std::vec::Vec::new())
    }

    // int32 data_type = 2;


    pub fn get_data_type(&self) -> i32 {
        self.data_type
    }
    pub fn clear_data_type(&mut self) {
        self.data_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: i32) {
        self.data_type = v;
    }

    // .onnx.TensorProto.Segment segment = 3;


    pub fn get_segment(&self) -> &TensorProto_Segment {
        self.segment.as_ref().unwrap_or_else(|| <TensorProto_Segment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_segment(&mut self) {
        self.segment.clear();
    }

    pub fn has_segment(&self) -> bool {
        self.segment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_segment(&mut self, v: TensorProto_Segment) {
        self.segment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_segment(&mut self) -> &mut TensorProto_Segment {
        if self.segment.is_none() {
            self.segment.set_default();
        }
        self.segment.as_mut().unwrap()
    }

    // Take field
    pub fn take_segment(&mut self) -> TensorProto_Segment {
        self.segment.take().unwrap_or_else(|| TensorProto_Segment::new())
    }

    // repeated float float_data = 4;


    pub fn get_float_data(&self) -> &[f32] {
        &self.float_data
    }
    pub fn clear_float_data(&mut self) {
        self.float_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_float_data(&mut self, v: ::std::vec::Vec<f32>) {
        self.float_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_float_data(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.float_data
    }

    // Take field
    pub fn take_float_data(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.float_data, ::std::vec::Vec::new())
    }

    // repeated int32 int32_data = 5;


    pub fn get_int32_data(&self) -> &[i32] {
        &self.int32_data
    }
    pub fn clear_int32_data(&mut self) {
        self.int32_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_int32_data(&mut self, v: ::std::vec::Vec<i32>) {
        self.int32_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int32_data(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.int32_data
    }

    // Take field
    pub fn take_int32_data(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.int32_data, ::std::vec::Vec::new())
    }

    // repeated bytes string_data = 6;


    pub fn get_string_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.string_data
    }
    pub fn clear_string_data(&mut self) {
        self.string_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.string_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_string_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.string_data
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.string_data, ::protobuf::RepeatedField::new())
    }

    // repeated int64 int64_data = 7;


    pub fn get_int64_data(&self) -> &[i64] {
        &self.int64_data
    }
    pub fn clear_int64_data(&mut self) {
        self.int64_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_int64_data(&mut self, v: ::std::vec::Vec<i64>) {
        self.int64_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int64_data(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.int64_data
    }

    // Take field
    pub fn take_int64_data(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.int64_data, ::std::vec::Vec::new())
    }

    // string name = 8;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string doc_string = 12;


    pub fn get_doc_string(&self) -> &str {
        &self.doc_string
    }
    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        &mut self.doc_string
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc_string, ::std::string::String::new())
    }

    // bytes raw_data = 9;


    pub fn get_raw_data(&self) -> &[u8] {
        &self.raw_data
    }
    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.raw_data
    }

    // Take field
    pub fn take_raw_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.raw_data, ::std::vec::Vec::new())
    }

    // repeated .onnx.StringStringEntryProto external_data = 13;


    pub fn get_external_data(&self) -> &[StringStringEntryProto] {
        &self.external_data
    }
    pub fn clear_external_data(&mut self) {
        self.external_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_data(&mut self, v: ::protobuf::RepeatedField<StringStringEntryProto>) {
        self.external_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_external_data(&mut self) -> &mut ::protobuf::RepeatedField<StringStringEntryProto> {
        &mut self.external_data
    }

    // Take field
    pub fn take_external_data(&mut self) -> ::protobuf::RepeatedField<StringStringEntryProto> {
        ::std::mem::replace(&mut self.external_data, ::protobuf::RepeatedField::new())
    }

    // .onnx.TensorProto.DataLocation data_location = 14;


    pub fn get_data_location(&self) -> TensorProto_DataLocation {
        self.data_location
    }
    pub fn clear_data_location(&mut self) {
        self.data_location = TensorProto_DataLocation::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_data_location(&mut self, v: TensorProto_DataLocation) {
        self.data_location = v;
    }

    // repeated double double_data = 10;


    pub fn get_double_data(&self) -> &[f64] {
        &self.double_data
    }
    pub fn clear_double_data(&mut self) {
        self.double_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_double_data(&mut self, v: ::std::vec::Vec<f64>) {
        self.double_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_double_data(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.double_data
    }

    // Take field
    pub fn take_double_data(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.double_data, ::std::vec::Vec::new())
    }

    // repeated uint64 uint64_data = 11;


    pub fn get_uint64_data(&self) -> &[u64] {
        &self.uint64_data
    }
    pub fn clear_uint64_data(&mut self) {
        self.uint64_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_uint64_data(&mut self, v: ::std::vec::Vec<u64>) {
        self.uint64_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uint64_data(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.uint64_data
    }

    // Take field
    pub fn take_uint64_data(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.uint64_data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TensorProto {
    fn is_initialized(&self) -> bool {
        for v in &self.segment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.external_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dims)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.data_type = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.segment)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.float_data)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.int32_data)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.string_data)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.int64_data)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc_string)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.raw_data)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.external_data)?;
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.data_location, 14, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.double_data)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.uint64_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dims {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.data_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.data_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.segment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.float_data.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.float_data.len() * 4) as u32) + (self.float_data.len() * 4) as u32;
        }
        if !self.int32_data.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(5, &self.int32_data);
        }
        for value in &self.string_data {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if !self.int64_data.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(7, &self.int64_data);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.name);
        }
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.doc_string);
        }
        if !self.raw_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.raw_data);
        }
        for value in &self.external_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.data_location != TensorProto_DataLocation::DEFAULT {
            my_size += ::protobuf::rt::enum_size(14, self.data_location);
        }
        if !self.double_data.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.double_data.len() * 8) as u32) + (self.double_data.len() * 8) as u32;
        }
        if !self.uint64_data.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(11, &self.uint64_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dims {
            os.write_int64(1, *v)?;
        };
        if self.data_type != 0 {
            os.write_int32(2, self.data_type)?;
        }
        if let Some(ref v) = self.segment.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.float_data.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.float_data.len() * 4) as u32)?;
            for v in &self.float_data {
                os.write_float_no_tag(*v)?;
            };
        }
        if !self.int32_data.is_empty() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.int32_data))?;
            for v in &self.int32_data {
                os.write_int32_no_tag(*v)?;
            };
        }
        for v in &self.string_data {
            os.write_bytes(6, &v)?;
        };
        if !self.int64_data.is_empty() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.int64_data))?;
            for v in &self.int64_data {
                os.write_int64_no_tag(*v)?;
            };
        }
        if !self.name.is_empty() {
            os.write_string(8, &self.name)?;
        }
        if !self.doc_string.is_empty() {
            os.write_string(12, &self.doc_string)?;
        }
        if !self.raw_data.is_empty() {
            os.write_bytes(9, &self.raw_data)?;
        }
        for v in &self.external_data {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.data_location != TensorProto_DataLocation::DEFAULT {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&self.data_location))?;
        }
        if !self.double_data.is_empty() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.double_data.len() * 8) as u32)?;
            for v in &self.double_data {
                os.write_double_no_tag(*v)?;
            };
        }
        if !self.uint64_data.is_empty() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.uint64_data))?;
            for v in &self.uint64_data {
                os.write_uint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorProto {
        TensorProto::new()
    }

    fn default_instance() -> &'static TensorProto {
        static instance: ::protobuf::rt::LazyV2<TensorProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorProto::new)
    }
}

impl ::protobuf::Clear for TensorProto {
    fn clear(&mut self) {
        self.dims.clear();
        self.data_type = 0;
        self.segment.clear();
        self.float_data.clear();
        self.int32_data.clear();
        self.string_data.clear();
        self.int64_data.clear();
        self.name.clear();
        self.doc_string.clear();
        self.raw_data.clear();
        self.external_data.clear();
        self.data_location = TensorProto_DataLocation::DEFAULT;
        self.double_data.clear();
        self.uint64_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TensorProto_Segment {
    // message fields
    pub begin: i64,
    pub end: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorProto_Segment {
    fn default() -> &'a TensorProto_Segment {
        <TensorProto_Segment as ::protobuf::Message>::default_instance()
    }
}

impl TensorProto_Segment {
    pub fn new() -> TensorProto_Segment {
        ::std::default::Default::default()
    }

    // int64 begin = 1;


    pub fn get_begin(&self) -> i64 {
        self.begin
    }
    pub fn clear_begin(&mut self) {
        self.begin = 0;
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: i64) {
        self.begin = v;
    }

    // int64 end = 2;


    pub fn get_end(&self) -> i64 {
        self.end
    }
    pub fn clear_end(&mut self) {
        self.end = 0;
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i64) {
        self.end = v;
    }
}

impl ::protobuf::Message for TensorProto_Segment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.begin = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.begin != 0 {
            my_size += ::protobuf::rt::value_size(1, self.begin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.begin != 0 {
            os.write_int64(1, self.begin)?;
        }
        if self.end != 0 {
            os.write_int64(2, self.end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorProto_Segment {
        TensorProto_Segment::new()
    }

    fn default_instance() -> &'static TensorProto_Segment {
        static instance: ::protobuf::rt::LazyV2<TensorProto_Segment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorProto_Segment::new)
    }
}

impl ::protobuf::Clear for TensorProto_Segment {
    fn clear(&mut self) {
        self.begin = 0;
        self.end = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto_Segment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TensorProto_DataType {
    UNDEFINED = 0,
    FLOAT = 1,
    UINT8 = 2,
    INT8 = 3,
    UINT16 = 4,
    INT16 = 5,
    INT32 = 6,
    INT64 = 7,
    STRING = 8,
    BOOL = 9,
    FLOAT16 = 10,
    DOUBLE = 11,
    UINT32 = 12,
    UINT64 = 13,
    COMPLEX64 = 14,
    COMPLEX128 = 15,
    BFLOAT16 = 16,
    FLOAT8E4M3FN = 17,
    FLOAT8E4M3FNUZ = 18,
    FLOAT8E5M2 = 19,
    FLOAT8E5M2FNUZ = 20,
}

impl ::protobuf::ProtobufEnum for TensorProto_DataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TensorProto_DataType> {
        match value {
            0 => ::std::option::Option::Some(TensorProto_DataType::UNDEFINED),
            1 => ::std::option::Option::Some(TensorProto_DataType::FLOAT),
            2 => ::std::option::Option::Some(TensorProto_DataType::UINT8),
            3 => ::std::option::Option::Some(TensorProto_DataType::INT8),
            4 => ::std::option::Option::Some(TensorProto_DataType::UINT16),
            5 => ::std::option::Option::Some(TensorProto_DataType::INT16),
            6 => ::std::option::Option::Some(TensorProto_DataType::INT32),
            7 => ::std::option::Option::Some(TensorProto_DataType::INT64),
            8 => ::std::option::Option::Some(TensorProto_DataType::STRING),
            9 => ::std::option::Option::Some(TensorProto_DataType::BOOL),
            10 => ::std::option::Option::Some(TensorProto_DataType::FLOAT16),
            11 => ::std::option::Option::Some(TensorProto_DataType::DOUBLE),
            12 => ::std::option::Option::Some(TensorProto_DataType::UINT32),
            13 => ::std::option::Option::Some(TensorProto_DataType::UINT64),
            14 => ::std::option::Option::Some(TensorProto_DataType::COMPLEX64),
            15 => ::std::option::Option::Some(TensorProto_DataType::COMPLEX128),
            16 => ::std::option::Option::Some(TensorProto_DataType::BFLOAT16),
            17 => ::std::option::Option::Some(TensorProto_DataType::FLOAT8E4M3FN),
            18 => ::std::option::Option::Some(TensorProto_DataType::FLOAT8E4M3FNUZ),
            19 => ::std::option::Option::Some(TensorProto_DataType::FLOAT8E5M2),
            20 => ::std::option::Option::Some(TensorProto_DataType::FLOAT8E5M2FNUZ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TensorProto_DataType] = &[
            TensorProto_DataType::UNDEFINED,
            TensorProto_DataType::FLOAT,
            TensorProto_DataType::UINT8,
            TensorProto_DataType::INT8,
            TensorProto_DataType::UINT16,
            TensorProto_DataType::INT16,
            TensorProto_DataType::INT32,
            TensorProto_DataType::INT64,
            TensorProto_DataType::STRING,
            TensorProto_DataType::BOOL,
            TensorProto_DataType::FLOAT16,
            TensorProto_DataType::DOUBLE,
            TensorProto_DataType::UINT32,
            TensorProto_DataType::UINT64,
            TensorProto_DataType::COMPLEX64,
            TensorProto_DataType::COMPLEX128,
            TensorProto_DataType::BFLOAT16,
            TensorProto_DataType::FLOAT8E4M3FN,
            TensorProto_DataType::FLOAT8E4M3FNUZ,
            TensorProto_DataType::FLOAT8E5M2,
            TensorProto_DataType::FLOAT8E5M2FNUZ,
        ];
        values
    }
}

impl ::std::marker::Copy for TensorProto_DataType {
}

impl ::std::default::Default for TensorProto_DataType {
    fn default() -> Self {
        TensorProto_DataType::UNDEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto_DataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TensorProto_DataLocation {
    DEFAULT = 0,
    EXTERNAL = 1,
}

impl ::protobuf::ProtobufEnum for TensorProto_DataLocation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TensorProto_DataLocation> {
        match value {
            0 => ::std::option::Option::Some(TensorProto_DataLocation::DEFAULT),
            1 => ::std::option::Option::Some(TensorProto_DataLocation::EXTERNAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TensorProto_DataLocation] = &[
            TensorProto_DataLocation::DEFAULT,
            TensorProto_DataLocation::EXTERNAL,
        ];
        values
    }
}

impl ::std::marker::Copy for TensorProto_DataLocation {
}

impl ::std::default::Default for TensorProto_DataLocation {
    fn default() -> Self {
        TensorProto_DataLocation::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto_DataLocation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SparseTensorProto {
    // message fields
    pub values: ::protobuf::SingularPtrField<TensorProto>,
    pub indices: ::protobuf::SingularPtrField<TensorProto>,
    pub dims: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SparseTensorProto {
    fn default() -> &'a SparseTensorProto {
        <SparseTensorProto as ::protobuf::Message>::default_instance()
    }
}

impl SparseTensorProto {
    pub fn new() -> SparseTensorProto {
        ::std::default::Default::default()
    }

    // .onnx.TensorProto values = 1;


    pub fn get_values(&self) -> &TensorProto {
        self.values.as_ref().unwrap_or_else(|| <TensorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    pub fn has_values(&self) -> bool {
        self.values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: TensorProto) {
        self.values = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_values(&mut self) -> &mut TensorProto {
        if self.values.is_none() {
            self.values.set_default();
        }
        self.values.as_mut().unwrap()
    }

    // Take field
    pub fn take_values(&mut self) -> TensorProto {
        self.values.take().unwrap_or_else(|| TensorProto::new())
    }

    // .onnx.TensorProto indices = 2;


    pub fn get_indices(&self) -> &TensorProto {
        self.indices.as_ref().unwrap_or_else(|| <TensorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_indices(&mut self) {
        self.indices.clear();
    }

    pub fn has_indices(&self) -> bool {
        self.indices.is_some()
    }

    // Param is passed by value, moved
    pub fn set_indices(&mut self, v: TensorProto) {
        self.indices = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_indices(&mut self) -> &mut TensorProto {
        if self.indices.is_none() {
            self.indices.set_default();
        }
        self.indices.as_mut().unwrap()
    }

    // Take field
    pub fn take_indices(&mut self) -> TensorProto {
        self.indices.take().unwrap_or_else(|| TensorProto::new())
    }

    // repeated int64 dims = 3;


    pub fn get_dims(&self) -> &[i64] {
        &self.dims
    }
    pub fn clear_dims(&mut self) {
        self.dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dims
    }

    // Take field
    pub fn take_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dims, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SparseTensorProto {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.indices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.values)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.indices)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dims)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.values.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.indices.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.dims {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.values.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.indices.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.dims {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SparseTensorProto {
        SparseTensorProto::new()
    }

    fn default_instance() -> &'static SparseTensorProto {
        static instance: ::protobuf::rt::LazyV2<SparseTensorProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SparseTensorProto::new)
    }
}

impl ::protobuf::Clear for SparseTensorProto {
    fn clear(&mut self) {
        self.values.clear();
        self.indices.clear();
        self.dims.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SparseTensorProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TensorShapeProto {
    // message fields
    pub dim: ::protobuf::RepeatedField<TensorShapeProto_Dimension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorShapeProto {
    fn default() -> &'a TensorShapeProto {
        <TensorShapeProto as ::protobuf::Message>::default_instance()
    }
}

impl TensorShapeProto {
    pub fn new() -> TensorShapeProto {
        ::std::default::Default::default()
    }

    // repeated .onnx.TensorShapeProto.Dimension dim = 1;


    pub fn get_dim(&self) -> &[TensorShapeProto_Dimension] {
        &self.dim
    }
    pub fn clear_dim(&mut self) {
        self.dim.clear();
    }

    // Param is passed by value, moved
    pub fn set_dim(&mut self, v: ::protobuf::RepeatedField<TensorShapeProto_Dimension>) {
        self.dim = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dim(&mut self) -> &mut ::protobuf::RepeatedField<TensorShapeProto_Dimension> {
        &mut self.dim
    }

    // Take field
    pub fn take_dim(&mut self) -> ::protobuf::RepeatedField<TensorShapeProto_Dimension> {
        ::std::mem::replace(&mut self.dim, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TensorShapeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dim {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dim)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dim {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dim {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorShapeProto {
        TensorShapeProto::new()
    }

    fn default_instance() -> &'static TensorShapeProto {
        static instance: ::protobuf::rt::LazyV2<TensorShapeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorShapeProto::new)
    }
}

impl ::protobuf::Clear for TensorShapeProto {
    fn clear(&mut self) {
        self.dim.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorShapeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TensorShapeProto_Dimension {
    // message fields
    pub denotation: ::std::string::String,
    // message oneof groups
    pub value: ::std::option::Option<TensorShapeProto_Dimension_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorShapeProto_Dimension {
    fn default() -> &'a TensorShapeProto_Dimension {
        <TensorShapeProto_Dimension as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TensorShapeProto_Dimension_oneof_value {
    dim_value(i64),
    dim_param(::std::string::String),
}

impl TensorShapeProto_Dimension {
    pub fn new() -> TensorShapeProto_Dimension {
        ::std::default::Default::default()
    }

    // int64 dim_value = 1;


    pub fn get_dim_value(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_dim_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_dim_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dim_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_value(v))
    }

    // string dim_param = 2;


    pub fn get_dim_param(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_dim_param(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_dim_param(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dim_param(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dim_param(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dim_param(&mut self) -> ::std::string::String {
        if self.has_dim_param() {
            match self.value.take() {
                ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string denotation = 3;


    pub fn get_denotation(&self) -> &str {
        &self.denotation
    }
    pub fn clear_denotation(&mut self) {
        self.denotation.clear();
    }

    // Param is passed by value, moved
    pub fn set_denotation(&mut self, v: ::std::string::String) {
        self.denotation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denotation(&mut self) -> &mut ::std::string::String {
        &mut self.denotation
    }

    // Take field
    pub fn take_denotation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denotation, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TensorShapeProto_Dimension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_value(is.read_int64()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TensorShapeProto_Dimension_oneof_value::dim_param(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denotation.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.denotation);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &TensorShapeProto_Dimension_oneof_value::dim_value(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TensorShapeProto_Dimension_oneof_value::dim_param(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denotation.is_empty() {
            os.write_string(3, &self.denotation)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &TensorShapeProto_Dimension_oneof_value::dim_value(v) => {
                    os.write_int64(1, v)?;
                },
                &TensorShapeProto_Dimension_oneof_value::dim_param(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorShapeProto_Dimension {
        TensorShapeProto_Dimension::new()
    }

    fn default_instance() -> &'static TensorShapeProto_Dimension {
        static instance: ::protobuf::rt::LazyV2<TensorShapeProto_Dimension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorShapeProto_Dimension::new)
    }
}

impl ::protobuf::Clear for TensorShapeProto_Dimension {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.denotation.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorShapeProto_Dimension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeProto {
    // message fields
    pub denotation: ::std::string::String,
    // message oneof groups
    pub value: ::std::option::Option<TypeProto_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeProto {
    fn default() -> &'a TypeProto {
        <TypeProto as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TypeProto_oneof_value {
    tensor_type(TypeProto_Tensor),
    sequence_type(TypeProto_Sequence),
    map_type(TypeProto_Map),
    optional_type(TypeProto_Optional),
    sparse_tensor_type(TypeProto_SparseTensor),
    opaque_type(TypeProto_Opaque),
}

impl TypeProto {
    pub fn new() -> TypeProto {
        ::std::default::Default::default()
    }

    // .onnx.TypeProto.Tensor tensor_type = 1;


    pub fn get_tensor_type(&self) -> &TypeProto_Tensor {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(ref v)) => v,
            _ => <TypeProto_Tensor as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_tensor_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_tensor_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tensor_type(&mut self, v: TypeProto_Tensor) {
        self.value = ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tensor_type(&mut self) -> &mut TypeProto_Tensor {
        if let ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(TypeProto_Tensor::new()));
        }
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tensor_type(&mut self) -> TypeProto_Tensor {
        if self.has_tensor_type() {
            match self.value.take() {
                ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeProto_Tensor::new()
        }
    }

    // .onnx.TypeProto.Sequence sequence_type = 4;


    pub fn get_sequence_type(&self) -> &TypeProto_Sequence {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::sequence_type(ref v)) => v,
            _ => <TypeProto_Sequence as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sequence_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sequence_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::sequence_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sequence_type(&mut self, v: TypeProto_Sequence) {
        self.value = ::std::option::Option::Some(TypeProto_oneof_value::sequence_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sequence_type(&mut self) -> &mut TypeProto_Sequence {
        if let ::std::option::Option::Some(TypeProto_oneof_value::sequence_type(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(TypeProto_oneof_value::sequence_type(TypeProto_Sequence::new()));
        }
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::sequence_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sequence_type(&mut self) -> TypeProto_Sequence {
        if self.has_sequence_type() {
            match self.value.take() {
                ::std::option::Option::Some(TypeProto_oneof_value::sequence_type(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeProto_Sequence::new()
        }
    }

    // .onnx.TypeProto.Map map_type = 5;


    pub fn get_map_type(&self) -> &TypeProto_Map {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::map_type(ref v)) => v,
            _ => <TypeProto_Map as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_map_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_map_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::map_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_type(&mut self, v: TypeProto_Map) {
        self.value = ::std::option::Option::Some(TypeProto_oneof_value::map_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_type(&mut self) -> &mut TypeProto_Map {
        if let ::std::option::Option::Some(TypeProto_oneof_value::map_type(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(TypeProto_oneof_value::map_type(TypeProto_Map::new()));
        }
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::map_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_type(&mut self) -> TypeProto_Map {
        if self.has_map_type() {
            match self.value.take() {
                ::std::option::Option::Some(TypeProto_oneof_value::map_type(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeProto_Map::new()
        }
    }

    // .onnx.TypeProto.Optional optional_type = 9;


    pub fn get_optional_type(&self) -> &TypeProto_Optional {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::optional_type(ref v)) => v,
            _ => <TypeProto_Optional as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_optional_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_optional_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::optional_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_optional_type(&mut self, v: TypeProto_Optional) {
        self.value = ::std::option::Option::Some(TypeProto_oneof_value::optional_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_optional_type(&mut self) -> &mut TypeProto_Optional {
        if let ::std::option::Option::Some(TypeProto_oneof_value::optional_type(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(TypeProto_oneof_value::optional_type(TypeProto_Optional::new()));
        }
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::optional_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_optional_type(&mut self) -> TypeProto_Optional {
        if self.has_optional_type() {
            match self.value.take() {
                ::std::option::Option::Some(TypeProto_oneof_value::optional_type(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeProto_Optional::new()
        }
    }

    // .onnx.TypeProto.SparseTensor sparse_tensor_type = 8;


    pub fn get_sparse_tensor_type(&self) -> &TypeProto_SparseTensor {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::sparse_tensor_type(ref v)) => v,
            _ => <TypeProto_SparseTensor as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sparse_tensor_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sparse_tensor_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::sparse_tensor_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sparse_tensor_type(&mut self, v: TypeProto_SparseTensor) {
        self.value = ::std::option::Option::Some(TypeProto_oneof_value::sparse_tensor_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sparse_tensor_type(&mut self) -> &mut TypeProto_SparseTensor {
        if let ::std::option::Option::Some(TypeProto_oneof_value::sparse_tensor_type(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(TypeProto_oneof_value::sparse_tensor_type(TypeProto_SparseTensor::new()));
        }
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::sparse_tensor_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sparse_tensor_type(&mut self) -> TypeProto_SparseTensor {
        if self.has_sparse_tensor_type() {
            match self.value.take() {
                ::std::option::Option::Some(TypeProto_oneof_value::sparse_tensor_type(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeProto_SparseTensor::new()
        }
    }

    // .onnx.TypeProto.Opaque opaque_type = 7;


    pub fn get_opaque_type(&self) -> &TypeProto_Opaque {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::opaque_type(ref v)) => v,
            _ => <TypeProto_Opaque as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_opaque_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_opaque_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::opaque_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_opaque_type(&mut self, v: TypeProto_Opaque) {
        self.value = ::std::option::Option::Some(TypeProto_oneof_value::opaque_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_opaque_type(&mut self) -> &mut TypeProto_Opaque {
        if let ::std::option::Option::Some(TypeProto_oneof_value::opaque_type(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(TypeProto_oneof_value::opaque_type(TypeProto_Opaque::new()));
        }
        match self.value {
            ::std::option::Option::Some(TypeProto_oneof_value::opaque_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_opaque_type(&mut self) -> TypeProto_Opaque {
        if self.has_opaque_type() {
            match self.value.take() {
                ::std::option::Option::Some(TypeProto_oneof_value::opaque_type(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeProto_Opaque::new()
        }
    }

    // string denotation = 6;


    pub fn get_denotation(&self) -> &str {
        &self.denotation
    }
    pub fn clear_denotation(&mut self) {
        self.denotation.clear();
    }

    // Param is passed by value, moved
    pub fn set_denotation(&mut self, v: ::std::string::String) {
        self.denotation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denotation(&mut self) -> &mut ::std::string::String {
        &mut self.denotation
    }

    // Take field
    pub fn take_denotation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denotation, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TypeProto {
    fn is_initialized(&self) -> bool {
        if let Some(TypeProto_oneof_value::tensor_type(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeProto_oneof_value::sequence_type(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeProto_oneof_value::map_type(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeProto_oneof_value::optional_type(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeProto_oneof_value::sparse_tensor_type(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeProto_oneof_value::opaque_type(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TypeProto_oneof_value::tensor_type(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TypeProto_oneof_value::sequence_type(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TypeProto_oneof_value::map_type(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TypeProto_oneof_value::optional_type(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TypeProto_oneof_value::sparse_tensor_type(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(TypeProto_oneof_value::opaque_type(is.read_message()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denotation.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.denotation);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &TypeProto_oneof_value::tensor_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeProto_oneof_value::sequence_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeProto_oneof_value::map_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeProto_oneof_value::optional_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeProto_oneof_value::sparse_tensor_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeProto_oneof_value::opaque_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denotation.is_empty() {
            os.write_string(6, &self.denotation)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &TypeProto_oneof_value::tensor_type(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeProto_oneof_value::sequence_type(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeProto_oneof_value::map_type(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeProto_oneof_value::optional_type(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeProto_oneof_value::sparse_tensor_type(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeProto_oneof_value::opaque_type(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeProto {
        TypeProto::new()
    }

    fn default_instance() -> &'static TypeProto {
        static instance: ::protobuf::rt::LazyV2<TypeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeProto::new)
    }
}

impl ::protobuf::Clear for TypeProto {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.denotation.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeProto_Tensor {
    // message fields
    pub elem_type: i32,
    pub shape: ::protobuf::SingularPtrField<TensorShapeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeProto_Tensor {
    fn default() -> &'a TypeProto_Tensor {
        <TypeProto_Tensor as ::protobuf::Message>::default_instance()
    }
}

impl TypeProto_Tensor {
    pub fn new() -> TypeProto_Tensor {
        ::std::default::Default::default()
    }

    // int32 elem_type = 1;


    pub fn get_elem_type(&self) -> i32 {
        self.elem_type
    }
    pub fn clear_elem_type(&mut self) {
        self.elem_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_elem_type(&mut self, v: i32) {
        self.elem_type = v;
    }

    // .onnx.TensorShapeProto shape = 2;


    pub fn get_shape(&self) -> &TensorShapeProto {
        self.shape.as_ref().unwrap_or_else(|| <TensorShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: TensorShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut TensorShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> TensorShapeProto {
        self.shape.take().unwrap_or_else(|| TensorShapeProto::new())
    }
}

impl ::protobuf::Message for TypeProto_Tensor {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.elem_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.elem_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.elem_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.elem_type != 0 {
            os.write_int32(1, self.elem_type)?;
        }
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeProto_Tensor {
        TypeProto_Tensor::new()
    }

    fn default_instance() -> &'static TypeProto_Tensor {
        static instance: ::protobuf::rt::LazyV2<TypeProto_Tensor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeProto_Tensor::new)
    }
}

impl ::protobuf::Clear for TypeProto_Tensor {
    fn clear(&mut self) {
        self.elem_type = 0;
        self.shape.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto_Tensor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeProto_Sequence {
    // message fields
    pub elem_type: ::protobuf::SingularPtrField<TypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeProto_Sequence {
    fn default() -> &'a TypeProto_Sequence {
        <TypeProto_Sequence as ::protobuf::Message>::default_instance()
    }
}

impl TypeProto_Sequence {
    pub fn new() -> TypeProto_Sequence {
        ::std::default::Default::default()
    }

    // .onnx.TypeProto elem_type = 1;


    pub fn get_elem_type(&self) -> &TypeProto {
        self.elem_type.as_ref().unwrap_or_else(|| <TypeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_elem_type(&mut self) {
        self.elem_type.clear();
    }

    pub fn has_elem_type(&self) -> bool {
        self.elem_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elem_type(&mut self, v: TypeProto) {
        self.elem_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_elem_type(&mut self) -> &mut TypeProto {
        if self.elem_type.is_none() {
            self.elem_type.set_default();
        }
        self.elem_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_elem_type(&mut self) -> TypeProto {
        self.elem_type.take().unwrap_or_else(|| TypeProto::new())
    }
}

impl ::protobuf::Message for TypeProto_Sequence {
    fn is_initialized(&self) -> bool {
        for v in &self.elem_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.elem_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.elem_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.elem_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeProto_Sequence {
        TypeProto_Sequence::new()
    }

    fn default_instance() -> &'static TypeProto_Sequence {
        static instance: ::protobuf::rt::LazyV2<TypeProto_Sequence> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeProto_Sequence::new)
    }
}

impl ::protobuf::Clear for TypeProto_Sequence {
    fn clear(&mut self) {
        self.elem_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto_Sequence {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeProto_Map {
    // message fields
    pub key_type: i32,
    pub value_type: ::protobuf::SingularPtrField<TypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeProto_Map {
    fn default() -> &'a TypeProto_Map {
        <TypeProto_Map as ::protobuf::Message>::default_instance()
    }
}

impl TypeProto_Map {
    pub fn new() -> TypeProto_Map {
        ::std::default::Default::default()
    }

    // int32 key_type = 1;


    pub fn get_key_type(&self) -> i32 {
        self.key_type
    }
    pub fn clear_key_type(&mut self) {
        self.key_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: i32) {
        self.key_type = v;
    }

    // .onnx.TypeProto value_type = 2;


    pub fn get_value_type(&self) -> &TypeProto {
        self.value_type.as_ref().unwrap_or_else(|| <TypeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value_type(&mut self) {
        self.value_type.clear();
    }

    pub fn has_value_type(&self) -> bool {
        self.value_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: TypeProto) {
        self.value_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_type(&mut self) -> &mut TypeProto {
        if self.value_type.is_none() {
            self.value_type.set_default();
        }
        self.value_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_type(&mut self) -> TypeProto {
        self.value_type.take().unwrap_or_else(|| TypeProto::new())
    }
}

impl ::protobuf::Message for TypeProto_Map {
    fn is_initialized(&self) -> bool {
        for v in &self.value_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_type != 0 {
            os.write_int32(1, self.key_type)?;
        }
        if let Some(ref v) = self.value_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeProto_Map {
        TypeProto_Map::new()
    }

    fn default_instance() -> &'static TypeProto_Map {
        static instance: ::protobuf::rt::LazyV2<TypeProto_Map> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeProto_Map::new)
    }
}

impl ::protobuf::Clear for TypeProto_Map {
    fn clear(&mut self) {
        self.key_type = 0;
        self.value_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto_Map {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeProto_Optional {
    // message fields
    pub elem_type: ::protobuf::SingularPtrField<TypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeProto_Optional {
    fn default() -> &'a TypeProto_Optional {
        <TypeProto_Optional as ::protobuf::Message>::default_instance()
    }
}

impl TypeProto_Optional {
    pub fn new() -> TypeProto_Optional {
        ::std::default::Default::default()
    }

    // .onnx.TypeProto elem_type = 1;


    pub fn get_elem_type(&self) -> &TypeProto {
        self.elem_type.as_ref().unwrap_or_else(|| <TypeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_elem_type(&mut self) {
        self.elem_type.clear();
    }

    pub fn has_elem_type(&self) -> bool {
        self.elem_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elem_type(&mut self, v: TypeProto) {
        self.elem_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_elem_type(&mut self) -> &mut TypeProto {
        if self.elem_type.is_none() {
            self.elem_type.set_default();
        }
        self.elem_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_elem_type(&mut self) -> TypeProto {
        self.elem_type.take().unwrap_or_else(|| TypeProto::new())
    }
}

impl ::protobuf::Message for TypeProto_Optional {
    fn is_initialized(&self) -> bool {
        for v in &self.elem_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.elem_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.elem_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.elem_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeProto_Optional {
        TypeProto_Optional::new()
    }

    fn default_instance() -> &'static TypeProto_Optional {
        static instance: ::protobuf::rt::LazyV2<TypeProto_Optional> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeProto_Optional::new)
    }
}

impl ::protobuf::Clear for TypeProto_Optional {
    fn clear(&mut self) {
        self.elem_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto_Optional {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeProto_SparseTensor {
    // message fields
    pub elem_type: i32,
    pub shape: ::protobuf::SingularPtrField<TensorShapeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeProto_SparseTensor {
    fn default() -> &'a TypeProto_SparseTensor {
        <TypeProto_SparseTensor as ::protobuf::Message>::default_instance()
    }
}

impl TypeProto_SparseTensor {
    pub fn new() -> TypeProto_SparseTensor {
        ::std::default::Default::default()
    }

    // int32 elem_type = 1;


    pub fn get_elem_type(&self) -> i32 {
        self.elem_type
    }
    pub fn clear_elem_type(&mut self) {
        self.elem_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_elem_type(&mut self, v: i32) {
        self.elem_type = v;
    }

    // .onnx.TensorShapeProto shape = 2;


    pub fn get_shape(&self) -> &TensorShapeProto {
        self.shape.as_ref().unwrap_or_else(|| <TensorShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: TensorShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut TensorShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> TensorShapeProto {
        self.shape.take().unwrap_or_else(|| TensorShapeProto::new())
    }
}

impl ::protobuf::Message for TypeProto_SparseTensor {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.elem_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.elem_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.elem_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.elem_type != 0 {
            os.write_int32(1, self.elem_type)?;
        }
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeProto_SparseTensor {
        TypeProto_SparseTensor::new()
    }

    fn default_instance() -> &'static TypeProto_SparseTensor {
        static instance: ::protobuf::rt::LazyV2<TypeProto_SparseTensor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeProto_SparseTensor::new)
    }
}

impl ::protobuf::Clear for TypeProto_SparseTensor {
    fn clear(&mut self) {
        self.elem_type = 0;
        self.shape.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto_SparseTensor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeProto_Opaque {
    // message fields
    pub domain: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeProto_Opaque {
    fn default() -> &'a TypeProto_Opaque {
        <TypeProto_Opaque as ::protobuf::Message>::default_instance()
    }
}

impl TypeProto_Opaque {
    pub fn new() -> TypeProto_Opaque {
        ::std::default::Default::default()
    }

    // string domain = 1;


    pub fn get_domain(&self) -> &str {
        &self.domain
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        &mut self.domain
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.domain, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TypeProto_Opaque {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.domain)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeProto_Opaque {
        TypeProto_Opaque::new()
    }

    fn default_instance() -> &'static TypeProto_Opaque {
        static instance: ::protobuf::rt::LazyV2<TypeProto_Opaque> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeProto_Opaque::new)
    }
}

impl ::protobuf::Clear for TypeProto_Opaque {
    fn clear(&mut self) {
        self.domain.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeProto_Opaque {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OperatorSetIdProto {
    // message fields
    pub domain: ::std::string::String,
    pub version: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperatorSetIdProto {
    fn default() -> &'a OperatorSetIdProto {
        <OperatorSetIdProto as ::protobuf::Message>::default_instance()
    }
}

impl OperatorSetIdProto {
    pub fn new() -> OperatorSetIdProto {
        ::std::default::Default::default()
    }

    // string domain = 1;


    pub fn get_domain(&self) -> &str {
        &self.domain
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        &mut self.domain
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.domain, ::std::string::String::new())
    }

    // int64 version = 2;


    pub fn get_version(&self) -> i64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.version = v;
    }
}

impl ::protobuf::Message for OperatorSetIdProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.domain)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        if self.version != 0 {
            os.write_int64(2, self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperatorSetIdProto {
        OperatorSetIdProto::new()
    }

    fn default_instance() -> &'static OperatorSetIdProto {
        static instance: ::protobuf::rt::LazyV2<OperatorSetIdProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OperatorSetIdProto::new)
    }
}

impl ::protobuf::Clear for OperatorSetIdProto {
    fn clear(&mut self) {
        self.domain.clear();
        self.version = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorSetIdProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FunctionProto {
    // message fields
    pub name: ::std::string::String,
    pub input: ::protobuf::RepeatedField<::std::string::String>,
    pub output: ::protobuf::RepeatedField<::std::string::String>,
    pub attribute: ::protobuf::RepeatedField<::std::string::String>,
    pub attribute_proto: ::protobuf::RepeatedField<AttributeProto>,
    pub node: ::protobuf::RepeatedField<NodeProto>,
    pub doc_string: ::std::string::String,
    pub opset_import: ::protobuf::RepeatedField<OperatorSetIdProto>,
    pub domain: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FunctionProto {
    fn default() -> &'a FunctionProto {
        <FunctionProto as ::protobuf::Message>::default_instance()
    }
}

impl FunctionProto {
    pub fn new() -> FunctionProto {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string input = 4;


    pub fn get_input(&self) -> &[::std::string::String] {
        &self.input
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input
    }

    // Take field
    pub fn take_input(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input, ::protobuf::RepeatedField::new())
    }

    // repeated string output = 5;


    pub fn get_output(&self) -> &[::std::string::String] {
        &self.output
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.output = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.output, ::protobuf::RepeatedField::new())
    }

    // repeated string attribute = 6;


    pub fn get_attribute(&self) -> &[::std::string::String] {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.attribute, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.AttributeProto attribute_proto = 11;


    pub fn get_attribute_proto(&self) -> &[AttributeProto] {
        &self.attribute_proto
    }
    pub fn clear_attribute_proto(&mut self) {
        self.attribute_proto.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_proto(&mut self, v: ::protobuf::RepeatedField<AttributeProto>) {
        self.attribute_proto = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_proto(&mut self) -> &mut ::protobuf::RepeatedField<AttributeProto> {
        &mut self.attribute_proto
    }

    // Take field
    pub fn take_attribute_proto(&mut self) -> ::protobuf::RepeatedField<AttributeProto> {
        ::std::mem::replace(&mut self.attribute_proto, ::protobuf::RepeatedField::new())
    }

    // repeated .onnx.NodeProto node = 7;


    pub fn get_node(&self) -> &[NodeProto] {
        &self.node
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: ::protobuf::RepeatedField<NodeProto>) {
        self.node = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node(&mut self) -> &mut ::protobuf::RepeatedField<NodeProto> {
        &mut self.node
    }

    // Take field
    pub fn take_node(&mut self) -> ::protobuf::RepeatedField<NodeProto> {
        ::std::mem::replace(&mut self.node, ::protobuf::RepeatedField::new())
    }

    // string doc_string = 8;


    pub fn get_doc_string(&self) -> &str {
        &self.doc_string
    }
    pub fn clear_doc_string(&mut self) {
        self.doc_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        &mut self.doc_string
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc_string, ::std::string::String::new())
    }

    // repeated .onnx.OperatorSetIdProto opset_import = 9;


    pub fn get_opset_import(&self) -> &[OperatorSetIdProto] {
        &self.opset_import
    }
    pub fn clear_opset_import(&mut self) {
        self.opset_import.clear();
    }

    // Param is passed by value, moved
    pub fn set_opset_import(&mut self, v: ::protobuf::RepeatedField<OperatorSetIdProto>) {
        self.opset_import = v;
    }

    // Mutable pointer to the field.
    pub fn mut_opset_import(&mut self) -> &mut ::protobuf::RepeatedField<OperatorSetIdProto> {
        &mut self.opset_import
    }

    // Take field
    pub fn take_opset_import(&mut self) -> ::protobuf::RepeatedField<OperatorSetIdProto> {
        ::std::mem::replace(&mut self.opset_import, ::protobuf::RepeatedField::new())
    }

    // string domain = 10;


    pub fn get_domain(&self) -> &str {
        &self.domain
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        &mut self.domain
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.domain, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FunctionProto {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute_proto {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.opset_import {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.output)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.attribute)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attribute_proto)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc_string)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.opset_import)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.domain)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.output {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.attribute {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.attribute_proto {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.doc_string.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.doc_string);
        }
        for value in &self.opset_import {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.domain);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.input {
            os.write_string(4, &v)?;
        };
        for v in &self.output {
            os.write_string(5, &v)?;
        };
        for v in &self.attribute {
            os.write_string(6, &v)?;
        };
        for v in &self.attribute_proto {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.node {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.doc_string.is_empty() {
            os.write_string(8, &self.doc_string)?;
        }
        for v in &self.opset_import {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.domain.is_empty() {
            os.write_string(10, &self.domain)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FunctionProto {
        FunctionProto::new()
    }

    fn default_instance() -> &'static FunctionProto {
        static instance: ::protobuf::rt::LazyV2<FunctionProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FunctionProto::new)
    }
}

impl ::protobuf::Clear for FunctionProto {
    fn clear(&mut self) {
        self.name.clear();
        self.input.clear();
        self.output.clear();
        self.attribute.clear();
        self.attribute_proto.clear();
        self.node.clear();
        self.doc_string.clear();
        self.opset_import.clear();
        self.domain.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Version {
    _START_VERSION = 0,
    IR_VERSION_2017_10_10 = 1,
    IR_VERSION_2017_10_30 = 2,
    IR_VERSION_2017_11_3 = 3,
    IR_VERSION_2019_1_22 = 4,
    IR_VERSION_2019_3_18 = 5,
    IR_VERSION_2019_9_19 = 6,
    IR_VERSION_2020_5_8 = 7,
    IR_VERSION_2021_7_30 = 8,
    IR_VERSION = 9,
}

impl ::protobuf::ProtobufEnum for Version {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Version> {
        match value {
            0 => ::std::option::Option::Some(Version::_START_VERSION),
            1 => ::std::option::Option::Some(Version::IR_VERSION_2017_10_10),
            2 => ::std::option::Option::Some(Version::IR_VERSION_2017_10_30),
            3 => ::std::option::Option::Some(Version::IR_VERSION_2017_11_3),
            4 => ::std::option::Option::Some(Version::IR_VERSION_2019_1_22),
            5 => ::std::option::Option::Some(Version::IR_VERSION_2019_3_18),
            6 => ::std::option::Option::Some(Version::IR_VERSION_2019_9_19),
            7 => ::std::option::Option::Some(Version::IR_VERSION_2020_5_8),
            8 => ::std::option::Option::Some(Version::IR_VERSION_2021_7_30),
            9 => ::std::option::Option::Some(Version::IR_VERSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Version] = &[
            Version::_START_VERSION,
            Version::IR_VERSION_2017_10_10,
            Version::IR_VERSION_2017_10_30,
            Version::IR_VERSION_2017_11_3,
            Version::IR_VERSION_2019_1_22,
            Version::IR_VERSION_2019_3_18,
            Version::IR_VERSION_2019_9_19,
            Version::IR_VERSION_2020_5_8,
            Version::IR_VERSION_2021_7_30,
            Version::IR_VERSION,
        ];
        values
    }
}

impl ::std::marker::Copy for Version {
}

impl ::std::default::Default for Version {
    fn default() -> Self {
        Version::_START_VERSION
    }
}

impl ::protobuf::reflect::ProtobufValue for Version {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperatorStatus {
    EXPERIMENTAL = 0,
    STABLE = 1,
}

impl ::protobuf::ProtobufEnum for OperatorStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperatorStatus> {
        match value {
            0 => ::std::option::Option::Some(OperatorStatus::EXPERIMENTAL),
            1 => ::std::option::Option::Some(OperatorStatus::STABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperatorStatus] = &[
            OperatorStatus::EXPERIMENTAL,
            OperatorStatus::STABLE,
        ];
        values
    }
}

impl ::std::marker::Copy for OperatorStatus {
}

impl ::std::default::Default for OperatorStatus {
    fn default() -> Self {
        OperatorStatus::EXPERIMENTAL
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
